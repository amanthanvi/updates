#!/bin/bash

set -o pipefail

UPDATES_VERSION="0.9.0"

SCRIPT_NAME="$(basename "$0")"

DRY_RUN=0
STRICT=0
NO_EMOJI=0
NO_COLOR_OUTPUT=0
NON_INTERACTIVE=0
PYTHON_BREAK_SYSTEM_PACKAGES=0
LOG_FILE=""
PARALLEL=4
SELF_UPDATE=1
NO_CONFIG=0
JSON=0
GO_BINARIES=""

LOG_LEVEL="info"
LOG_LEVEL_NUM=2
HUMAN_FD=1

BREW_GREEDY=1
BREW_CLEANUP=1
BREW_CASKS=1
BREW_CASKS_EXPLICIT=0

MAS_UPGRADE=0
MACOS_UPDATES=0

only_modules=()
skip_modules=()
config_skip_modules=()
successes=()
skipped=()
failures=()

CURRENT_MODULE="main"

COLOR_STDOUT=0
COLOR_STDERR=0
C_RESET=""
C_BOLD=""
C_DIM=""
C_RED=""
C_GREEN=""
C_YELLOW=""
C_BLUE=""

print() {
	printf '%s\n' "$*" >&"$HUMAN_FD"
}

set_log_level() {
	case "$1" in
	error)
		LOG_LEVEL="error"
		LOG_LEVEL_NUM=0
		;;
	warn)
		LOG_LEVEL="warn"
		LOG_LEVEL_NUM=1
		;;
	info)
		LOG_LEVEL="info"
		LOG_LEVEL_NUM=2
		;;
	debug)
		LOG_LEVEL="debug"
		LOG_LEVEL_NUM=3
		;;
	*)
		die "--log-level must be one of: error, warn, info, debug"
		;;
	esac
}

json_enabled() {
	[ "$JSON" -eq 1 ]
}

json_timestamp() {
	date -u +%Y-%m-%dT%H:%M:%SZ
}

json_escape() {
	local s="$1"
	s="${s//\\/\\\\}"
	s="${s//\"/\\\"}"
	s="${s//$'\n'/\\n}"
	s="${s//$'\r'/\\r}"
	s="${s//$'\t'/\\t}"
	printf '%s' "$s"
}

json_emit_message_event() {
	local event="$1"
	local module="$2"
	local message="$3"

	if ! json_enabled; then
		return 0
	fi

	local ts
	ts="$(json_timestamp)"

	printf '{"event":"%s","module":"%s","message":"%s","timestamp":"%s"}\n' \
		"$event" \
		"$(json_escape "$module")" \
		"$(json_escape "$message")" \
		"$ts"
}

json_emit_module_start() {
	local module="$1"

	if ! json_enabled; then
		return 0
	fi

	local ts
	ts="$(json_timestamp)"

	printf '{"event":"module_start","module":"%s","timestamp":"%s"}\n' \
		"$(json_escape "$module")" \
		"$ts"
}

json_emit_module_end() {
	local module="$1"
	local status="$2"
	local seconds="$3"

	if ! json_enabled; then
		return 0
	fi

	local ts
	ts="$(json_timestamp)"

	printf '{"event":"module_end","module":"%s","status":"%s","seconds":%s,"timestamp":"%s"}\n' \
		"$(json_escape "$module")" \
		"$(json_escape "$status")" \
		"$seconds" \
		"$ts"
}

json_array() {
	local first=1
	printf '['
	local item
	for item in "$@"; do
		if [ "$first" -eq 0 ]; then
			printf ','
		fi
		first=0
		printf '"%s"' "$(json_escape "$item")"
	done
	printf ']'
}

json_emit_summary() {
	local ok="$1"
	local skip="$2"
	local fail="$3"
	local total_seconds="$4"
	shift 4
	local -a failures=("$@")

	if ! json_enabled; then
		return 0
	fi

	local ts
	ts="$(json_timestamp)"

	printf '{"event":"summary","ok":%s,"skip":%s,"fail":%s,"total_seconds":%s,"failures":%s,"timestamp":"%s"}\n' \
		"$ok" \
		"$skip" \
		"$fail" \
		"$total_seconds" \
		"$(json_array "${failures[@]}")" \
		"$ts"
}

progress() {
	if [ "$LOG_LEVEL_NUM" -ge 1 ]; then
		print "$*"
	fi
}

log() {
	json_emit_message_event log "$CURRENT_MODULE" "$*"
	if [ "$LOG_LEVEL_NUM" -ge 2 ]; then
		print "$*"
	fi
}

debug() {
	json_emit_message_event log "$CURRENT_MODULE" "$*"
	if [ "$LOG_LEVEL_NUM" -ge 3 ]; then
		print "$*"
	fi
}

init_colors() {
	COLOR_STDOUT=0
	COLOR_STDERR=0
	C_RESET=""
	C_BOLD=""
	C_DIM=""
	C_RED=""
	C_GREEN=""
	C_YELLOW=""
	C_BLUE=""

	if [ "$NO_COLOR_OUTPUT" -eq 1 ] || [ -n "${NO_COLOR:-}" ] || [ "${TERM:-}" = "dumb" ]; then
		return 0
	fi

	if [ -t 1 ]; then
		COLOR_STDOUT=1
	fi
	if [ -t 2 ]; then
		COLOR_STDERR=1
	fi

	if [ "$COLOR_STDOUT" -eq 0 ] && [ "$COLOR_STDERR" -eq 0 ]; then
		return 0
	fi

	C_RESET=$'\033[0m'
	C_BOLD=$'\033[1m'
	C_DIM=$'\033[2m'
	C_RED=$'\033[31m'
	C_GREEN=$'\033[32m'
	C_YELLOW=$'\033[33m'
	C_BLUE=$'\033[34m'
}

warn() {
	json_emit_message_event warn "$CURRENT_MODULE" "$*"
	if [ "$LOG_LEVEL_NUM" -lt 1 ]; then
		return 0
	fi
	if [ "$COLOR_STDERR" -eq 1 ]; then
		printf '%s\n' "${C_YELLOW}WARN:${C_RESET} $*" >&2
	else
		printf '%s\n' "WARN: $*" >&2
	fi
}

err() {
	json_emit_message_event error "$CURRENT_MODULE" "$*"
	if [ "$COLOR_STDERR" -eq 1 ]; then
		printf '%s\n' "${C_RED}ERROR:${C_RESET} $*" >&2
	else
		printf '%s\n' "ERROR: $*" >&2
	fi
}

die() {
	err "$*"
	exit 2
}

emoji() {
	if [ "$NO_EMOJI" -eq 1 ]; then
		return 0
	fi
	printf '%s' "$1"
}

format_boundary_start() {
	local module="$1"
	if [ "$COLOR_STDOUT" -eq 1 ]; then
		printf '%s %s START' "${C_BLUE}${C_BOLD}==>${C_RESET}" "${C_BOLD}${module}${C_RESET}"
		return 0
	fi
	printf '==> %s START' "$module"
}

format_boundary_end() {
	local module="$1"
	local status="$2"
	local dur="$3"

	if [ "$COLOR_STDOUT" -ne 1 ]; then
		printf '==> %s END (%s) (%ss)' "$module" "$status" "$dur"
		return 0
	fi

	local status_color=""
	case "$status" in
	OK) status_color="$C_GREEN" ;;
	SKIP) status_color="$C_YELLOW" ;;
	FAIL) status_color="$C_RED" ;;
	esac

	printf '%s %s END (%s%s%s) %s(%ss)%s' \
		"${C_BLUE}${C_BOLD}==>${C_RESET}" \
		"${C_BOLD}${module}${C_RESET}" \
		"$status_color" "$status" "$C_RESET" \
		"$C_DIM" "$dur" "$C_RESET"
}

format_summary() {
	local ok="$1"
	local skip="$2"
	local fail="$3"
	local total="$4"
	local failures_csv="${5:-}"

	if [ "$COLOR_STDOUT" -ne 1 ]; then
		local line="==> SUMMARY ok=${ok} skip=${skip} fail=${fail} total=${total}s"
		if [ -n "$failures_csv" ]; then
			line="${line} failures=${failures_csv}"
		fi
		printf '%s' "$line"
		return 0
	fi

	local line="${C_BLUE}${C_BOLD}==>${C_RESET} ${C_BOLD}SUMMARY${C_RESET}"
	line="${line} ${C_GREEN}ok=${ok}${C_RESET}"
	line="${line} ${C_YELLOW}skip=${skip}${C_RESET}"
	line="${line} ${C_RED}fail=${fail}${C_RESET}"
	line="${line} ${C_DIM}total=${total}s${C_RESET}"
	if [ -n "$failures_csv" ]; then
		line="${line} ${C_RED}failures=${failures_csv}${C_RESET}"
	fi
	printf '%s' "$line"
}

cmd_exists() {
	command -v "$1" >/dev/null 2>&1
}

is_macos() {
	[ "$(uname -s)" = "Darwin" ]
}

is_linux() {
	[ "$(uname -s)" = "Linux" ]
}

is_wsl() {
	# WSL1/WSL2 detection heuristics.
	# Prefer env var; fall back to /proc markers.
	if [ -n "${WSL_DISTRO_NAME:-}" ]; then
		return 0
	fi
	if [ -f /proc/sys/kernel/osrelease ] && grep -qi microsoft /proc/sys/kernel/osrelease; then
		return 0
	fi
	if [ -f /proc/version ] && grep -qi microsoft /proc/version; then
		return 0
	fi
	return 1
}

apply_platform_defaults() {
	# macOS 26+ introduces App Management prompts for app bundle updates (/Applications).
	# Default to formula upgrades only unless explicitly opted in.
	if is_macos && [ "$BREW_CASKS_EXPLICIT" -eq 0 ]; then
		BREW_CASKS=0
	fi
}

set_brew_mode() {
	local mode="$1"
	local ctx="${2:-cli}"

	case "$mode" in
	formula)
		BREW_CASKS=0
		BREW_GREEDY=0
		BREW_CASKS_EXPLICIT=1
		;;
	casks)
		BREW_CASKS=1
		BREW_GREEDY=0
		BREW_CASKS_EXPLICIT=1
		;;
	greedy)
		BREW_CASKS=1
		BREW_GREEDY=1
		BREW_CASKS_EXPLICIT=1
		;;
	*)
		if [ "$ctx" = "config" ]; then
			warn "config: BREW_MODE must be formula, casks, or greedy (got: $mode)"
			return 1
		fi
		die "--brew-mode must be one of: formula, casks, greedy"
		;;
	esac
}

module_supported() {
	# When UPDATES_ALLOW_NON_DARWIN=1 is set, allow command-driven modules to run
	# on unknown platforms, but still treat OS-specific modules as unsupported.
	case "$1" in
	brew | shell | node | python | uv | pipx | rustup | claude | mise | go) return 0 ;;
	linux) is_linux ;;
	mas | macos) is_macos ;;
	*) return 1 ;;
	esac
}

require_supported_platform() {
	if is_macos || is_linux; then
		return 0
	fi
	if [ "${UPDATES_ALLOW_NON_DARWIN:-0}" = "1" ]; then
		warn "Unsupported OS detected; continuing because UPDATES_ALLOW_NON_DARWIN=1 is set."
		return 0
	fi
	die "This script targets macOS and Linux. Set UPDATES_ALLOW_NON_DARWIN=1 to bypass."
}

validate_only_modules_supported() {
	if [ "${#only_modules[@]}" -eq 0 ]; then
		return 0
	fi

	local m
	for m in "${only_modules[@]}"; do
		if module_supported "$m"; then
			continue
		fi
		die "$m: module is not supported on this platform"
	done
}

run() {
	debug "+ $*"
	if [ "$DRY_RUN" -eq 1 ]; then
		return 0
	fi
	if [ "$JSON" -eq 1 ]; then
		"$@" 1>&2
	else
		"$@"
	fi
}

semver_is_valid() {
	[[ "${1:-}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]
}

semver_lt() {
	# Returns 0 if $1 < $2, else 1.
	local a="$1"
	local b="$2"
	semver_is_valid "$a" || return 1
	semver_is_valid "$b" || return 1

	local a1 a2 a3 b1 b2 b3
	IFS=. read -r a1 a2 a3 <<<"$a"
	IFS=. read -r b1 b2 b3 <<<"$b"

	if [ "$a1" -ne "$b1" ]; then
		[ "$a1" -lt "$b1" ]
		return $?
	fi
	if [ "$a2" -ne "$b2" ]; then
		[ "$a2" -lt "$b2" ]
		return $?
	fi
	[ "$a3" -lt "$b3" ]
	return $?
}

self_update_enabled() {
	if [ "$SELF_UPDATE" -ne 1 ]; then
		return 1
	fi
	if [ "${UPDATES_SELF_UPDATE:-1}" = "0" ]; then
		return 1
	fi
	if [ -n "${CI:-}" ]; then
		return 1
	fi
	if [ "${UPDATES_SELF_UPDATED:-0}" = "1" ]; then
		return 1
	fi
	# Do not self-update in dry-run mode.
	if [ "$DRY_RUN" -eq 1 ]; then
		return 1
	fi
	return 0
}

self_update_resolve_self_path() {
	local self="$0"
	if [ -f "$self" ]; then
		print "$self"
		return 0
	fi

	self="$(command -v "$SCRIPT_NAME" 2>/dev/null || true)"
	[ -n "$self" ] || return 1
	[ -f "$self" ] || return 1
	print "$self"
	return 0
}

self_update_is_git_checkout() {
	local self_path="$1"
	if ! cmd_exists git; then
		return 1
	fi

	local dir=""
	dir="$(cd "$(dirname "$self_path")" && pwd)"
	git -C "$dir" rev-parse --is-inside-work-tree >/dev/null 2>&1
}

self_update_latest_tag_github() {
	local repo="$1"
	local api="https://api.github.com/repos/${repo}/releases/latest"

	local json=""
	json="$(curl -fsSL --connect-timeout 2 --max-time 5 "$api" 2>/dev/null)" || return 1

	local tag=""
	tag="$(printf '%s' "$json" | sed -nE 's/.*"tag_name"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/p' | head -n 1)"
	[ -n "$tag" ] || return 1
	print "$tag"
}

self_update_sha256_file() {
	local path="$1"
	if cmd_exists sha256sum; then
		sha256sum "$path" | awk '{print $1}'
		return 0
	fi
	if cmd_exists shasum; then
		shasum -a 256 "$path" | awk '{print $1}'
		return 0
	fi
	return 1
}

maybe_self_update() {
	if ! self_update_enabled; then
		return 0
	fi
	if ! cmd_exists curl; then
		debug "self-update: curl not found; skipping"
		return 0
	fi
	if ! cmd_exists install; then
		debug "self-update: install not found; skipping"
		return 0
	fi

	local self_path=""
	if ! self_path="$(self_update_resolve_self_path)"; then
		debug "self-update: failed to resolve script path; skipping"
		return 0
	fi

	# Avoid mutating a git checkout; self-update is for installed binaries.
	if self_update_is_git_checkout "$self_path"; then
		debug "self-update: running from git checkout ($self_path); skipping"
		return 0
	fi

	local repo="${UPDATES_SELF_UPDATE_REPO:-amanthanvi/updates}"
	local tag=""
	if ! tag="$(self_update_latest_tag_github "$repo")"; then
		debug "self-update: failed to fetch latest release tag; skipping"
		return 0
	fi

	local latest="${tag#v}"
	if ! semver_is_valid "$latest"; then
		debug "self-update: latest tag is not SemVer: $tag"
		return 0
	fi

	if ! semver_lt "$UPDATES_VERSION" "$latest"; then
		return 0
	fi

	warn "updates: self-update available (${UPDATES_VERSION} -> ${latest})"

	local tmp_dir=""
	tmp_dir="$(mktemp -d 2>/dev/null || mktemp -d -t updates-self-update)" || {
		debug "self-update: mktemp failed; skipping"
		return 0
	}

	local base_url="https://github.com/${repo}/releases/download/${tag}"
	local tmp_updates="${tmp_dir}/updates"
	local tmp_sums="${tmp_dir}/SHA256SUMS"

	if ! curl -fsSL --connect-timeout 2 --max-time 20 -o "$tmp_updates" "${base_url}/updates" 2>/dev/null; then
		warn "updates: self-update download failed; continuing"
		rm -rf "$tmp_dir"
		return 0
	fi
	if ! curl -fsSL --connect-timeout 2 --max-time 20 -o "$tmp_sums" "${base_url}/SHA256SUMS" 2>/dev/null; then
		warn "updates: self-update checksum download failed; continuing"
		rm -rf "$tmp_dir"
		return 0
	fi

	local expected=""
	expected="$(awk '$2 ~ /(^|\/)updates$/{print $1; exit}' "$tmp_sums" 2>/dev/null || true)"
	if [ -z "$expected" ]; then
		warn "updates: self-update checksum missing; continuing"
		rm -rf "$tmp_dir"
		return 0
	fi

	local actual=""
	if ! actual="$(self_update_sha256_file "$tmp_updates")"; then
		warn "updates: self-update sha256 tool missing; continuing"
		rm -rf "$tmp_dir"
		return 0
	fi
	if [ "$actual" != "$expected" ]; then
		warn "updates: self-update checksum mismatch; continuing"
		rm -rf "$tmp_dir"
		return 0
	fi

	if ! grep -q '^UPDATES_VERSION=' "$tmp_updates"; then
		warn "updates: self-update downloaded script looks invalid; continuing"
		rm -rf "$tmp_dir"
		return 0
	fi

	if [ -L "$self_path" ]; then
		warn "updates: self-update skipped (installed as symlink): $self_path"
		rm -rf "$tmp_dir"
		return 0
	fi

	if [ -w "$self_path" ]; then
		if ! install -m 0755 "$tmp_updates" "$self_path"; then
			warn "updates: self-update install failed; continuing"
			rm -rf "$tmp_dir"
			return 0
		fi
	else
		if ! cmd_exists sudo; then
			warn "updates: self-update requires write access to $self_path (try installing to ~/.local/bin)"
			rm -rf "$tmp_dir"
			return 0
		fi

		local -a sudo_prefix=(sudo)
		if [ "$NON_INTERACTIVE" -eq 1 ]; then
			sudo_prefix=(sudo -n)
		fi
		if ! "${sudo_prefix[@]}" install -m 0755 "$tmp_updates" "$self_path"; then
			warn "updates: self-update requires sudo or a user-writable install location (e.g. ~/.local/bin)"
			rm -rf "$tmp_dir"
			return 0
		fi
	fi

	rm -rf "$tmp_dir"

	warn "updates: updated to ${latest}; restarting"
	export UPDATES_SELF_UPDATED=1
	exec "$self_path" "$@"
}

contains_word() {
	local needle="$1"
	shift
	local item
	for item in "$@"; do
		if [ "$item" = "$needle" ]; then
			return 0
		fi
	done
	return 1
}

normalize_module_list() {
	# Converts a CSV list like "brew, mas,python" to space-separated words.
	local s="$1"
	s="${s//,/ }"
	print "$s"
}

is_module_known() {
	case "$1" in
	brew | shell | linux | node | python | uv | mas | pipx | rustup | claude | mise | go | macos) return 0 ;;
	*) return 1 ;;
	esac
}

module_description() {
	case "$1" in
	brew) print "Update Homebrew formulae (+ optional casks)" ;;
	shell) print "Update Oh My Zsh and custom git plugins/themes" ;;
	linux) print "Upgrade Linux system packages" ;;
	node) print "Upgrade global npm packages via ncu" ;;
	python) print "Upgrade global Python packages via pip" ;;
	uv) print "Update uv and uv-managed tools" ;;
	mas) print "Upgrade Mac App Store apps via mas (opt-in)" ;;
	pipx) print "Upgrade pipx-managed apps via pipx" ;;
	rustup) print "Update Rust toolchains via rustup" ;;
	claude) print "Update Claude Code CLI" ;;
	mise) print "Update mise and upgrade installed tools" ;;
	go) print "Update Go binaries from GO_BINARIES config" ;;
	macos) print "List available macOS software updates (opt-in)" ;;
	*) print "" ;;
	esac
}

list_modules() {
	local m
	for m in brew shell linux node python uv mas pipx rustup claude mise go macos; do
		printf '%-8s %s\n' "$m" "$(module_description "$m")"
	done
}

usage() {
	cat <<EOF
${SCRIPT_NAME} v${UPDATES_VERSION}

Updates common tooling on macOS and Linux (Homebrew, npm globals, pip globals, etc.).

Usage:
  ${SCRIPT_NAME} [options]

Options:
  -h, --help               Show this help
      --version            Print version
      --list-modules       List available modules
      --dry-run            Print what would run; make no changes
      --only <list>        Run only these modules (CSV; or quote a space-separated list)
      --skip <list>        Skip these modules (CSV; or quote a space-separated list)
      --strict             Stop on first failure
      --log-level <level>  Output level: error, warn, info, debug (default: info)
      --json               Emit JSONL events to stdout (human output to stderr)
      --[no-]self-update   Check GitHub for a newer version and update this script (default: enabled)
  -n, --non-interactive    Avoid interactive prompts when possible
      --no-config          Ignore ~/.updatesrc
      --no-emoji           Disable emoji in output
      --no-color           Disable ANSI colors in output
      --log-file <path>    Append human output to a log file
      --parallel <N>       Parallelism for pip upgrades (default: ${PARALLEL})
      --pip-force          Pass --break-system-packages to pip (dangerous)
      --brew-mode <mode>   Homebrew scope: formula, casks, greedy
      --[no-]brew-cleanup  Run brew cleanup after upgrade (default: enabled)
      --full               Enable everything (brew greedy + mas + macos + all detected modules)
      --[no-]mas-upgrade   Upgrade Mac App Store apps (default: disabled)
      --[no-]macos-updates List available macOS software updates (default: disabled)

Examples:
  ${SCRIPT_NAME}
  ${SCRIPT_NAME} --dry-run
  ${SCRIPT_NAME} --only brew,node --brew-mode formula
  ${SCRIPT_NAME} --json -n --no-self-update --log-level warn
  ${SCRIPT_NAME} --skip python --log-file ./updates.log

EOF
}

pre_scan_no_config() {
	local arg
	for arg in "$@"; do
		case "$arg" in
		--no-config)
			NO_CONFIG=1
			;;
		--json)
			JSON=1
			;;
		-h | --help | --version | --list-modules)
			# These commands don't need config defaults; avoid config parse warnings
			# polluting help/version output (and keep --json + --help sane).
			NO_CONFIG=1
			;;
		esac
	done
	return 0
}

config_parse_module_list() {
	local list="$1"
	local m
	for m in $(normalize_module_list "$list"); do
		[ -n "$m" ] || continue
		if ! is_module_known "$m"; then
			warn "config: unknown module in SKIP_MODULES: $m"
			continue
		fi
		config_skip_modules+=("$m")
	done
}

read_config() {
	if [ "$NO_CONFIG" -eq 1 ]; then
		return 0
	fi

	local config_path="${HOME}/.updatesrc"
	if [ ! -f "$config_path" ]; then
		return 0
	fi

	local line key val
	while IFS= read -r line || [ -n "$line" ]; do
		# Trim whitespace.
		line="${line#"${line%%[![:space:]]*}"}"
		line="${line%"${line##*[![:space:]]}"}"

		# Skip empty lines and comments.
		[ -n "$line" ] || continue
		case "$line" in
		\#*) continue ;;
		esac

		if ! [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
			continue
		fi

		key="${BASH_REMATCH[1]}"
		val="${BASH_REMATCH[2]}"

		# Trim whitespace around the value.
		val="${val#"${val%%[![:space:]]*}"}"
		val="${val%"${val##*[![:space:]]}"}"

		# Strip a single layer of surrounding quotes.
		case "$val" in
		\"*\")
			val="${val#\"}"
			val="${val%\"}"
			;;
		\'*\')
			val="${val#\'}"
			val="${val%\'}"
			;;
		esac

		case "$key" in
		SKIP_MODULES)
			config_skip_modules=()
			config_parse_module_list "$val"
			;;
		BREW_MODE)
			set_brew_mode "$val" config || true
			;;
		BREW_CLEANUP)
			case "$val" in
			0) BREW_CLEANUP=0 ;;
			1) BREW_CLEANUP=1 ;;
			*) warn "config: BREW_CLEANUP must be 0 or 1 (got: $val)" ;;
			esac
			;;
		MAS_UPGRADE)
			case "$val" in
			0) MAS_UPGRADE=0 ;;
			1) MAS_UPGRADE=1 ;;
			*) warn "config: MAS_UPGRADE must be 0 or 1 (got: $val)" ;;
			esac
			;;
		MACOS_UPDATES)
			case "$val" in
			0) MACOS_UPDATES=0 ;;
			1) MACOS_UPDATES=1 ;;
			*) warn "config: MACOS_UPDATES must be 0 or 1 (got: $val)" ;;
			esac
			;;
		LOG_LEVEL)
			case "$val" in
			error | warn | info | debug) set_log_level "$val" ;;
			*) warn "config: LOG_LEVEL must be error, warn, info, or debug (got: $val)" ;;
			esac
			;;
		PARALLEL)
			case "$val" in
			'' | *[!0-9]*)
				warn "config: PARALLEL must be a positive integer (got: $val)"
				;;
			*)
				if [ "$val" -lt 1 ]; then
					warn "config: PARALLEL must be >= 1 (got: $val)"
				else
					PARALLEL="$val"
				fi
				;;
			esac
			;;
		PIP_FORCE)
			case "$val" in
			0) PYTHON_BREAK_SYSTEM_PACKAGES=0 ;;
			1) PYTHON_BREAK_SYSTEM_PACKAGES=1 ;;
			*) warn "config: PIP_FORCE must be 0 or 1 (got: $val)" ;;
			esac
			;;
		SELF_UPDATE)
			case "$val" in
			0) SELF_UPDATE=0 ;;
			1) SELF_UPDATE=1 ;;
			*) warn "config: SELF_UPDATE must be 0 or 1 (got: $val)" ;;
			esac
			;;
		NO_EMOJI)
			case "$val" in
			0) NO_EMOJI=0 ;;
			1) NO_EMOJI=1 ;;
			*) warn "config: NO_EMOJI must be 0 or 1 (got: $val)" ;;
			esac
			;;
		NO_COLOR)
			case "$val" in
			0) NO_COLOR_OUTPUT=0 ;;
			1) NO_COLOR_OUTPUT=1 ;;
			*) warn "config: NO_COLOR must be 0 or 1 (got: $val)" ;;
			esac
			;;
		GO_BINARIES)
			GO_BINARIES="$val"
			;;
		*)
			# Unknown keys are ignored for forward compatibility.
			:
			;;
		esac
	done <"$config_path"
}

parse_args() {
	while [ $# -gt 0 ]; do
		case "$1" in
		-h | --help)
			usage
			exit 0
			;;
		--version)
			print "${UPDATES_VERSION}"
			exit 0
			;;
		--list-modules)
			list_modules
			exit 0
			;;
		--dry-run)
			DRY_RUN=1
			;;
		--strict)
			STRICT=1
			;;
		--log-level)
			shift
			[ $# -gt 0 ] || die "--log-level requires a value"
			set_log_level "$1"
			;;
		--json)
			JSON=1
			;;
		--self-update)
			SELF_UPDATE=1
			;;
		--no-self-update)
			SELF_UPDATE=0
			;;
		--no-emoji)
			NO_EMOJI=1
			;;
		--no-color)
			NO_COLOR_OUTPUT=1
			;;
		--no-config)
			NO_CONFIG=1
			;;
		-n | --non-interactive)
			NON_INTERACTIVE=1
			;;
		--pip-force)
			PYTHON_BREAK_SYSTEM_PACKAGES=1
			;;
		--full)
			set_brew_mode greedy
			MAS_UPGRADE=1
			MACOS_UPDATES=1
			;;
		--log-file)
			shift
			[ $# -gt 0 ] || die "--log-file requires a path"
			LOG_FILE="$1"
			;;
		--parallel)
			shift
			[ $# -gt 0 ] || die "--parallel requires a number"
			PARALLEL="$1"
			case "$PARALLEL" in
			'' | *[!0-9]*)
				die "--parallel must be a positive integer"
				;;
			esac
			if [ "$PARALLEL" -lt 1 ]; then
				die "--parallel must be >= 1"
			fi
			;;
		--only)
			shift
			[ $# -gt 0 ] || die "--only requires a module list"
			local list
			list="$(normalize_module_list "$1")"
			local m
			for m in $list; do
				is_module_known "$m" || die "Unknown module in --only: $m"
				only_modules+=("$m")
			done
			;;
		--skip)
			shift
			[ $# -gt 0 ] || die "--skip requires a module list"
			local list
			list="$(normalize_module_list "$1")"
			local m
			for m in $list; do
				is_module_known "$m" || die "Unknown module in --skip: $m"
				skip_modules+=("$m")
			done
			;;
		--brew-mode)
			shift
			[ $# -gt 0 ] || die "--brew-mode requires a value"
			set_brew_mode "$1"
			;;
		--brew-cleanup)
			BREW_CLEANUP=1
			;;
		--no-brew-cleanup)
			BREW_CLEANUP=0
			;;
		--mas-upgrade)
			MAS_UPGRADE=1
			;;
		--no-mas-upgrade)
			MAS_UPGRADE=0
			;;
		--macos-updates)
			MACOS_UPDATES=1
			;;
		--no-macos-updates)
			MACOS_UPDATES=0
			;;
		--)
			shift
			break
			;;
		-*)
			die "Unknown option: $1"
			;;
		*)
			die "Unexpected argument: $1"
			;;
		esac
		shift
	done
}

module_selected() {
	local name="$1"

	if contains_word "$name" "${skip_modules[@]}"; then
		return 1
	fi

	if [ "${#only_modules[@]}" -gt 0 ]; then
		contains_word "$name" "${only_modules[@]}"
		return $?
	fi

	if contains_word "$name" "${config_skip_modules[@]}"; then
		return 1
	fi

	if [ "$name" = "mas" ] && [ "$MAS_UPGRADE" -eq 0 ]; then
		return 1
	fi

	if [ "$name" = "macos" ] && [ "$MACOS_UPDATES" -eq 0 ]; then
		return 1
	fi

	module_supported "$name"
}

module_dependency_missing() {
	# In --only mode, missing deps should be treated as an error.
	if [ "${#only_modules[@]}" -gt 0 ]; then
		return 0
	fi
	return 1
}

ensure_cmd_or_skip() {
	local cmd="$1"
	local module="$2"
	if cmd_exists "$cmd"; then
		return 0
	fi

	if module_dependency_missing; then
		err "$module: required command not found: $cmd"
		return 1
	fi

	log "Skipping $module: $cmd not found."
	return 2
}

json_pairs() {
	# Prints tab-delimited key/value pairs from a JSON object on stdin.
	if cmd_exists python3; then
		python3 -c 'import sys, json; obj=json.load(sys.stdin); [print(f"{k}\t{v}") for k,v in obj.items()]'
		return $?
	fi
	if cmd_exists node; then
		node -e 'let d="";process.stdin.on("data",c=>d+=c);process.stdin.on("end",()=>{const o=JSON.parse(d||"{}");for(const k of Object.keys(o)){process.stdout.write(k+"\t"+o[k]+"\n");}});'
		return $?
	fi
	return 1
}

python_externally_managed() {
	if ! cmd_exists python3; then
		return 1
	fi

	local out
	if ! out="$(
		python3 -c 'import sysconfig, pathlib; paths=sysconfig.get_paths(); c=[pathlib.Path(paths[k])/"EXTERNALLY-MANAGED" for k in ("stdlib","platstdlib","purelib","platlib") if paths.get(k)]; print("1" if any(p.exists() for p in c) else "0")' 2>/dev/null
	)"; then
		return 1
	fi
	[ "$out" = "1" ]
}

module_brew() {
	log "Homebrew $(emoji "üç∫")"
	ensure_cmd_or_skip brew brew || return $?

	if is_macos && [ "$BREW_CASKS" -eq 0 ] && [ "$BREW_CASKS_EXPLICIT" -eq 0 ]; then
		warn "Defaulting to brew formula upgrades only on macOS. Enable casks with --brew-mode casks (or --full)."
	fi

	if is_macos && [ "$BREW_CASKS" -eq 1 ]; then
		warn "Homebrew cask upgrades may modify /Applications."
		warn "On macOS 26+, cask upgrades may be blocked unless your terminal app is allowed under Privacy & Security ‚Üí App Management."
		warn "If you see a system notification like \"<Terminal App> tried modifying your system but was stopped/prevented\", enable App Management for your terminal app (e.g. Ghostty), or rerun with --brew-mode formula."
	fi

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: brew update"
		if [ "$BREW_CASKS" -eq 0 ]; then
			log "DRY RUN: brew upgrade --formula"
		elif [ "$BREW_GREEDY" -eq 1 ]; then
			log "DRY RUN: brew upgrade --greedy"
		else
			log "DRY RUN: brew upgrade"
		fi
		if [ "$BREW_CLEANUP" -eq 1 ]; then
			log "DRY RUN: brew cleanup"
		fi
		return 0
	fi

	run brew update || return 1

	if [ "$BREW_CASKS" -eq 0 ]; then
		run brew upgrade --formula || return 1
	elif [ "$BREW_GREEDY" -eq 1 ]; then
		run brew upgrade --greedy || return 1
	else
		run brew upgrade || return 1
	fi

	if [ "$BREW_CLEANUP" -eq 1 ]; then
		run brew cleanup || return 1
	fi

	return 0
}

shell_git_is_repo() {
	local dir="$1"
	[ -e "${dir}/.git" ]
}

shell_detect_omz_dir() {
	if [ -n "${ZSH:-}" ] && [ -d "${ZSH}" ]; then
		print "$ZSH"
		return 0
	fi
	if [ -d "${HOME}/.oh-my-zsh" ]; then
		print "${HOME}/.oh-my-zsh"
		return 0
	fi
	return 1
}

shell_detect_omz_custom_dir() {
	local zsh_dir="$1"
	if [ -n "${ZSH_CUSTOM:-}" ] && [ -d "${ZSH_CUSTOM}" ]; then
		print "$ZSH_CUSTOM"
		return 0
	fi
	if [ -d "${zsh_dir}/custom" ]; then
		print "${zsh_dir}/custom"
		return 0
	fi
	return 1
}

module_shell() {
	log "Shell customization $(emoji "üêö")"
	ensure_cmd_or_skip git shell || return $?

	local omz_dir=""
	if ! omz_dir="$(shell_detect_omz_dir)"; then
		log "Skipping shell: Oh My Zsh not found."
		return 2
	fi

	local custom_dir=""
	custom_dir="$(shell_detect_omz_custom_dir "$omz_dir" || true)"

	local git_terminal_prompt_prev=""
	local git_terminal_prompt_was_set=0
	if [ "$NON_INTERACTIVE" -eq 1 ]; then
		if [ -n "${GIT_TERMINAL_PROMPT+x}" ]; then
			git_terminal_prompt_was_set=1
			git_terminal_prompt_prev="${GIT_TERMINAL_PROMPT}"
		fi
		export GIT_TERMINAL_PROMPT=0
	fi

	local -a repos=()
	if shell_git_is_repo "$omz_dir"; then
		repos+=("$omz_dir")
	else
		warn "shell: Oh My Zsh is not a git repo: ${omz_dir}"
	fi

	if [ -n "$custom_dir" ]; then
		local root
		for root in "${custom_dir}/plugins" "${custom_dir}/themes"; do
			if [ ! -d "$root" ]; then
				continue
			fi

			local dir
			for dir in "${root}"/*; do
				[ -e "$dir" ] || continue
				[ -d "$dir" ] || continue
				if shell_git_is_repo "$dir"; then
					repos+=("$dir")
				fi
			done
		done
	fi

	if [ "${#repos[@]}" -eq 0 ]; then
		log "Skipping shell: no git repos detected."
		if [ "$NON_INTERACTIVE" -eq 1 ]; then
			if [ "$git_terminal_prompt_was_set" -eq 1 ]; then
				export GIT_TERMINAL_PROMPT="$git_terminal_prompt_prev"
			else
				unset GIT_TERMINAL_PROMPT
			fi
		fi
		return 2
	fi

	local failed=0
	local repo
	for repo in "${repos[@]}"; do
		if [ "$DRY_RUN" -eq 1 ]; then
			log "DRY RUN: git -C ${repo} pull --ff-only"
			continue
		fi

		log "Updating: ${repo}"
		if ! run git -C "$repo" pull --ff-only; then
			failed=1
		fi
	done

	if [ "$NON_INTERACTIVE" -eq 1 ]; then
		if [ "$git_terminal_prompt_was_set" -eq 1 ]; then
			export GIT_TERMINAL_PROMPT="$git_terminal_prompt_prev"
		else
			unset GIT_TERMINAL_PROMPT
		fi
	fi

	if [ "$failed" -eq 1 ]; then
		return 1
	fi
	return 0
}

module_linux() {
	if ! is_linux; then
		return 2
	fi

	log "Linux system packages $(emoji "üêß")"

	local pm=""
	if cmd_exists apt-get; then
		pm="apt-get"
	elif cmd_exists dnf; then
		pm="dnf"
	elif cmd_exists yum; then
		pm="yum"
	elif cmd_exists pacman; then
		pm="pacman"
	elif cmd_exists zypper; then
		pm="zypper"
	elif cmd_exists apk; then
		pm="apk"
	else
		if module_dependency_missing; then
			err "linux: no supported package manager found (apt-get/dnf/yum/pacman/zypper/apk)"
			return 1
		fi
		log "Skipping linux: no supported package manager found."
		return 2
	fi

	local -a sudo_prefix=()
	if [ "$(id -u)" -ne 0 ]; then
		if ! cmd_exists sudo; then
			err "linux: requires root or sudo"
			return 1
		fi
		sudo_prefix=(sudo)
		if [ "$NON_INTERACTIVE" -eq 1 ]; then
			sudo_prefix=(sudo -n)
		fi
	fi

	case "$pm" in
	apt-get)
		local -a env_prefix=()
		if [ "$NON_INTERACTIVE" -eq 1 ]; then
			env_prefix=(env DEBIAN_FRONTEND=noninteractive)
		fi

		local -a update_cmd=("${sudo_prefix[@]}" "${env_prefix[@]}" apt-get update)
		local -a upgrade_cmd=("${sudo_prefix[@]}" "${env_prefix[@]}" apt-get upgrade)
		if [ "$NON_INTERACTIVE" -eq 1 ]; then
			upgrade_cmd+=(-y)
		fi

		if [ "$DRY_RUN" -eq 1 ]; then
			log "DRY RUN: ${update_cmd[*]}"
			log "DRY RUN: ${upgrade_cmd[*]}"
			return 0
		fi

		run "${update_cmd[@]}" || return 1
		run "${upgrade_cmd[@]}" || return 1
		return 0
		;;
	dnf)
		local -a upgrade_cmd=("${sudo_prefix[@]}" dnf upgrade)
		if [ "$NON_INTERACTIVE" -eq 1 ]; then
			upgrade_cmd+=(-y)
		fi

		if [ "$DRY_RUN" -eq 1 ]; then
			log "DRY RUN: ${upgrade_cmd[*]}"
			return 0
		fi

		run "${upgrade_cmd[@]}" || return 1
		return 0
		;;
	yum)
		local -a upgrade_cmd=("${sudo_prefix[@]}" yum update)
		if [ "$NON_INTERACTIVE" -eq 1 ]; then
			upgrade_cmd+=(-y)
		fi

		if [ "$DRY_RUN" -eq 1 ]; then
			log "DRY RUN: ${upgrade_cmd[*]}"
			return 0
		fi

		run "${upgrade_cmd[@]}" || return 1
		return 0
		;;
	pacman)
		local -a upgrade_cmd=("${sudo_prefix[@]}" pacman -Syu)
		if [ "$NON_INTERACTIVE" -eq 1 ]; then
			upgrade_cmd+=(--noconfirm)
		fi

		if [ "$DRY_RUN" -eq 1 ]; then
			log "DRY RUN: ${upgrade_cmd[*]}"
			return 0
		fi

		run "${upgrade_cmd[@]}" || return 1
		return 0
		;;
	zypper)
		local -a refresh_cmd=("${sudo_prefix[@]}" zypper refresh)
		local -a update_cmd=("${sudo_prefix[@]}" zypper update)
		if [ "$NON_INTERACTIVE" -eq 1 ]; then
			refresh_cmd+=(--non-interactive)
			update_cmd+=(--non-interactive)
		fi

		if [ "$DRY_RUN" -eq 1 ]; then
			log "DRY RUN: ${refresh_cmd[*]}"
			log "DRY RUN: ${update_cmd[*]}"
			return 0
		fi

		run "${refresh_cmd[@]}" || return 1
		run "${update_cmd[@]}" || return 1
		return 0
		;;
	apk)
		local -a update_cmd=("${sudo_prefix[@]}" apk update)
		local -a upgrade_cmd=("${sudo_prefix[@]}" apk upgrade)

		if [ "$DRY_RUN" -eq 1 ]; then
			log "DRY RUN: ${update_cmd[*]}"
			log "DRY RUN: ${upgrade_cmd[*]}"
			return 0
		fi

		run "${update_cmd[@]}" || return 1
		run "${upgrade_cmd[@]}" || return 1
		return 0
		;;
	*)
		err "linux: unsupported package manager: $pm"
		return 1
		;;
	esac
}

module_node() {
	log "npm globals $(emoji "üì¶")"
	ensure_cmd_or_skip ncu node || return $?
	ensure_cmd_or_skip npm node || return $?

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: ncu -g --jsonUpgraded"
		log "DRY RUN: npm install -g -- <packages...>"
		return 0
	fi

	local json
	if ! json="$(ncu -g --jsonUpgraded)"; then
		err "node: ncu failed"
		return 1
	fi

	local pairs
	if ! pairs="$(printf '%s' "$json" | json_pairs)"; then
		err "node: failed to parse ncu JSON output"
		return 1
	fi

	local -a packages=()
	local name ver
	while IFS=$'\t' read -r name ver; do
		[ -n "$name" ] || continue
		packages+=("${name}@${ver}")
	done <<<"$pairs"

	if [ "${#packages[@]}" -eq 0 ]; then
		log "All global npm packages are up-to-date. $(emoji "‚úÖ")"
		return 0
	fi

	log "Upgrading global npm packages:"
	local p
	for p in "${packages[@]}"; do
		log "  - $p"
	done

	run npm install -g -- "${packages[@]}" || return 1
	return 0
}

module_python() {
	log "Python globals $(emoji "üêç")"
	ensure_cmd_or_skip python3 python || return $?

	if ! python3 -m pip --version >/dev/null 2>&1; then
		if module_dependency_missing; then
			err "python: required module not found: pip (python3 -m pip)"
			return 1
		fi
		log "Skipping python: pip not available (python3 -m pip)."
		return 2
	fi

	local use_user=0
	local break_system=0
	if [ "$PYTHON_BREAK_SYSTEM_PACKAGES" -eq 1 ]; then
		break_system=1
	elif python_externally_managed; then
		use_user=1
		log "python: externally-managed environment detected; upgrading user-site packages."
		log "python: use --pip-force to override (dangerous)."
	fi

	local -a pip_list_args=(python3 -m pip --disable-pip-version-check list --outdated --format=json)
	local -a pip_install_args=(python3 -m pip --disable-pip-version-check install -U)
	if [ "$NON_INTERACTIVE" -eq 1 ]; then
		pip_install_args+=(--no-input)
	fi
	if [ "$use_user" -eq 1 ]; then
		pip_list_args+=(--user)
		pip_install_args+=(--user)
	fi
	if [ "$break_system" -eq 1 ]; then
		pip_install_args+=(--break-system-packages)
	fi

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: ${pip_list_args[*]}"
		log "DRY RUN: ${pip_install_args[*]} <package>  (parallel: ${PARALLEL})"
		return 0
	fi

	local outdated_json
	if ! outdated_json="$("${pip_list_args[@]}")"; then
		err "python: failed to query outdated packages"
		return 1
	fi

	local names
	if ! names="$(printf '%s' "$outdated_json" | python3 -c 'import sys, json; data=json.load(sys.stdin); print("\n".join([p.get("name","") for p in data if p.get("name")]))' 2>/dev/null)"; then
		err "python: failed to parse pip output"
		return 1
	fi

	local -a packages=()
	local pkg
	while IFS= read -r pkg; do
		[ -n "$pkg" ] || continue
		packages+=("$pkg")
	done <<<"$names"

	if [ "${#packages[@]}" -eq 0 ]; then
		if [ "$use_user" -eq 1 ]; then
			log "All user-site Python packages are up-to-date. $(emoji "‚úÖ")"
		else
			log "All Python packages are up-to-date. $(emoji "‚úÖ")"
		fi
		return 0
	fi

	if [ "$PARALLEL" -lt 1 ] 2>/dev/null; then
		PARALLEL=1
	fi

	log "Upgrading ${#packages[@]} Python packages (parallel: ${PARALLEL})..."

	local -a pids=()
	local -a pid_pkgs=()
	local failed=0

	for pkg in "${packages[@]}"; do
		debug "+ ${pip_install_args[*]} $pkg"
		if [ "$JSON" -eq 1 ]; then
			"${pip_install_args[@]}" "$pkg" 1>&2 &
		else
			"${pip_install_args[@]}" "$pkg" &
		fi
		pids+=("$!")
		pid_pkgs+=("$pkg")

		if [ "${#pids[@]}" -ge "$PARALLEL" ]; then
			local pid="${pids[0]}"
			local pid_pkg="${pid_pkgs[0]}"
			if ! wait "$pid"; then
				err "python: pip upgrade failed: $pid_pkg"
				failed=1
			fi
			pids=("${pids[@]:1}")
			pid_pkgs=("${pid_pkgs[@]:1}")
		fi
	done

	local i
	for i in "${!pids[@]}"; do
		if ! wait "${pids[$i]}"; then
			err "python: pip upgrade failed: ${pid_pkgs[$i]}"
			failed=1
		fi
	done

	if [ "$failed" -ne 0 ]; then
		return 1
	fi
	return 0
}

module_uv() {
	log "uv $(emoji "‚ö°")"
	ensure_cmd_or_skip uv uv || return $?

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: uv self update"
		log "DRY RUN: uv tool upgrade --all"
		return 0
	fi

	run uv self update || return 1
	run uv tool upgrade --all || return 1
	return 0
}

module_mas() {
	log "Mac App Store $(emoji "üõçÔ∏è")"
	ensure_cmd_or_skip mas mas || return $?

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: mas upgrade"
		return 0
	fi

	run mas upgrade || return 1
	return 0
}

module_pipx() {
	log "pipx $(emoji "üß∞")"
	ensure_cmd_or_skip pipx pipx || return $?

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: pipx upgrade-all"
		return 0
	fi

	run pipx upgrade-all || return 1
	return 0
}

module_rustup() {
	log "Rust $(emoji "ü¶Ä")"
	ensure_cmd_or_skip rustup rustup || return $?

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: rustup update"
		return 0
	fi

	run rustup update || return 1
	return 0
}

module_claude() {
	log "Claude Code $(emoji "ü§ñ")"
	ensure_cmd_or_skip claude claude || return $?

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: claude update"
		return 0
	fi

	run claude update || return 1
	return 0
}

module_mise() {
	log "mise $(emoji "üß©")"
	ensure_cmd_or_skip mise mise || return $?

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: mise self-update"
		log "DRY RUN: mise upgrade"
		return 0
	fi

	run mise self-update || return 1
	run mise upgrade || return 1
	return 0
}

module_go() {
	log "Go binaries $(emoji "üêπ")"
	ensure_cmd_or_skip go go || return $?

	if [ -z "${GO_BINARIES}" ]; then
		if module_dependency_missing; then
			err "go: GO_BINARIES is not configured (set GO_BINARIES=... in ~/.updatesrc)"
			return 1
		fi
		log "Skipping go: GO_BINARIES not configured."
		return 2
	fi

	local list
	list="$(normalize_module_list "$GO_BINARIES")"

	local -a specs=()
	local entry
	for entry in $list; do
		[ -n "$entry" ] || continue
		if [[ "$entry" == *@* ]]; then
			specs+=("$entry")
		else
			specs+=("${entry}@latest")
		fi
	done

	if [ "${#specs[@]}" -eq 0 ]; then
		if module_dependency_missing; then
			err "go: GO_BINARIES is empty (set GO_BINARIES=... in ~/.updatesrc)"
			return 1
		fi
		log "Skipping go: GO_BINARIES is empty."
		return 2
	fi

	if [ "$DRY_RUN" -eq 1 ]; then
		local spec
		for spec in "${specs[@]}"; do
			log "DRY RUN: go install ${spec}"
		done
		return 0
	fi

	local failed=0
	local spec
	for spec in "${specs[@]}"; do
		if ! run go install "${spec}"; then
			err "go: install failed: ${spec}"
			failed=1
		fi
	done

	if [ "$failed" -ne 0 ]; then
		return 1
	fi
	return 0
}

module_macos() {
	log "macOS updates $(emoji "üçè")"
	ensure_cmd_or_skip softwareupdate macos || return $?

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: softwareupdate -l"
		return 0
	fi

	run softwareupdate -l || return 1
	return 0
}

csv_join() {
	local IFS=,
	print "$*"
}

run_selected_modules() {
	successes=()
	skipped=()
	failures=()

	local m
	for m in brew shell linux node python uv mas pipx rustup claude mise go macos; do
		if ! module_selected "$m"; then
			continue
		fi

		json_emit_module_start "$m"
		progress "$(format_boundary_start "$m")"
		local start="$SECONDS"

		CURRENT_MODULE="$m"
		debug "Running module: $m"
		local rc=0
		"module_${m}"
		rc=$?
		CURRENT_MODULE="main"
		local dur=$((SECONDS - start))

		if [ "$rc" -eq 0 ]; then
			successes+=("$m")
			json_emit_module_end "$m" ok "$dur"
			progress "$(format_boundary_end "$m" OK "$dur")"
			continue
		fi

		# 2 means "skipped due to missing dependency"
		if [ "$rc" -eq 2 ]; then
			skipped+=("$m")
			json_emit_module_end "$m" skip "$dur"
			progress "$(format_boundary_end "$m" SKIP "$dur")"
			continue
		fi

		failures+=("$m")
		json_emit_module_end "$m" fail "$dur"
		progress "$(format_boundary_end "$m" FAIL "$dur")"
		if [ "$STRICT" -eq 1 ]; then
			return 1
		fi
	done

	if [ "${#failures[@]}" -gt 0 ]; then
		return 1
	fi
	return 0
}

on_interrupt() {
	local code="$1"
	local sig="$2"
	err "Interrupted ($sig)."
	exit "$code"
}

main() {
	pre_scan_no_config "$@"
	read_config
	parse_args "$@"

	if [ "$JSON" -eq 1 ]; then
		HUMAN_FD=2
	fi

	if [ -n "$LOG_FILE" ] && [ "${UPDATES_LOG_REDIRECTED:-0}" != "1" ]; then
		mkdir -p "$(dirname "$LOG_FILE")" || die "Failed to create log dir"
		export UPDATES_LOG_REDIRECTED=1
		if [ "$JSON" -eq 1 ]; then
			exec 2> >(tee -a "$LOG_FILE" >&2)
		else
			exec > >(tee -a "$LOG_FILE") 2>&1
		fi
	fi

	init_colors
	apply_platform_defaults

	require_supported_platform
	validate_only_modules_supported

	trap 'on_interrupt 130 SIGINT' INT
	trap 'on_interrupt 143 SIGTERM' TERM

	maybe_self_update "$@"

	debug "log-level: ${LOG_LEVEL}"

	log "Starting updates..."
	SECONDS=0

	local rc=0
	if run_selected_modules; then
		local total="${SECONDS}"
		json_emit_summary "${#successes[@]}" "${#skipped[@]}" "${#failures[@]}" "$total" "${failures[@]}"
		progress "$(format_summary "${#successes[@]}" "${#skipped[@]}" "${#failures[@]}" "$total")"
		log "Done in ${total}s. $(emoji "üéâ")"
		return 0
	fi

	local total="${SECONDS}"
	local failures_csv=""
	if [ "${#failures[@]}" -gt 0 ]; then
		failures_csv="$(csv_join "${failures[@]}")"
	fi
	json_emit_summary "${#successes[@]}" "${#skipped[@]}" "${#failures[@]}" "$total" "${failures[@]}"
	progress "$(format_summary "${#successes[@]}" "${#skipped[@]}" "${#failures[@]}" "$total" "$failures_csv")"
	err "Completed in ${total}s with failures: ${failures[*]}"
	return 1
}

main "$@"
