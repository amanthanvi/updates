#!/bin/bash

set -o pipefail

UPDATES_VERSION="0.5.1"

SCRIPT_NAME="$(basename "$0")"

DRY_RUN=0
STRICT=0
QUIET=0
VERBOSE=0
NO_EMOJI=0
NO_COLOR_OUTPUT=0
NON_INTERACTIVE=0
PYTHON_BREAK_SYSTEM_PACKAGES=0
LOG_FILE=""
PARALLEL=4

BREW_GREEDY=1
BREW_CLEANUP=1

only_modules=()
skip_modules=()
successes=()
skipped=()
failures=()

COLOR_STDOUT=0
COLOR_STDERR=0
C_RESET=""
C_BOLD=""
C_DIM=""
C_RED=""
C_GREEN=""
C_YELLOW=""
C_BLUE=""

print() {
	printf '%s\n' "$*"
}

log() {
	if [ "$QUIET" -eq 0 ]; then
		print "$*"
	fi
}

debug() {
	if [ "$VERBOSE" -eq 1 ]; then
		print "$*"
	fi
}

init_colors() {
	COLOR_STDOUT=0
	COLOR_STDERR=0
	C_RESET=""
	C_BOLD=""
	C_DIM=""
	C_RED=""
	C_GREEN=""
	C_YELLOW=""
	C_BLUE=""

	if [ "$NO_COLOR_OUTPUT" -eq 1 ] || [ -n "${NO_COLOR:-}" ] || [ "${TERM:-}" = "dumb" ]; then
		return 0
	fi

	if [ -t 1 ]; then
		COLOR_STDOUT=1
	fi
	if [ -t 2 ]; then
		COLOR_STDERR=1
	fi

	if [ "$COLOR_STDOUT" -eq 0 ] && [ "$COLOR_STDERR" -eq 0 ]; then
		return 0
	fi

	C_RESET=$'\033[0m'
	C_BOLD=$'\033[1m'
	C_DIM=$'\033[2m'
	C_RED=$'\033[31m'
	C_GREEN=$'\033[32m'
	C_YELLOW=$'\033[33m'
	C_BLUE=$'\033[34m'
}

warn() {
	if [ "$COLOR_STDERR" -eq 1 ]; then
		print "${C_YELLOW}WARN:${C_RESET} $*" >&2
	else
		print "WARN: $*" >&2
	fi
}

err() {
	if [ "$COLOR_STDERR" -eq 1 ]; then
		print "${C_RED}ERROR:${C_RESET} $*" >&2
	else
		print "ERROR: $*" >&2
	fi
}

die() {
	err "$*"
	exit 2
}

emoji() {
	if [ "$NO_EMOJI" -eq 1 ]; then
		return 0
	fi
	printf '%s' "$1"
}

format_boundary_start() {
	local module="$1"
	if [ "$COLOR_STDOUT" -eq 1 ]; then
		printf '%s %s START' "${C_BLUE}${C_BOLD}==>${C_RESET}" "${C_BOLD}${module}${C_RESET}"
		return 0
	fi
	printf '==> %s START' "$module"
}

format_boundary_end() {
	local module="$1"
	local status="$2"
	local dur="$3"

	if [ "$COLOR_STDOUT" -ne 1 ]; then
		printf '==> %s END (%s) (%ss)' "$module" "$status" "$dur"
		return 0
	fi

	local status_color=""
	case "$status" in
	OK) status_color="$C_GREEN" ;;
	SKIP) status_color="$C_YELLOW" ;;
	FAIL) status_color="$C_RED" ;;
	esac

	printf '%s %s END (%s%s%s) %s(%ss)%s' \
		"${C_BLUE}${C_BOLD}==>${C_RESET}" \
		"${C_BOLD}${module}${C_RESET}" \
		"$status_color" "$status" "$C_RESET" \
		"$C_DIM" "$dur" "$C_RESET"
}

format_summary() {
	local ok="$1"
	local skip="$2"
	local fail="$3"
	local total="$4"
	local failures_csv="${5:-}"

	if [ "$COLOR_STDOUT" -ne 1 ]; then
		local line="==> SUMMARY ok=${ok} skip=${skip} fail=${fail} total=${total}s"
		if [ -n "$failures_csv" ]; then
			line="${line} failures=${failures_csv}"
		fi
		printf '%s' "$line"
		return 0
	fi

	local line="${C_BLUE}${C_BOLD}==>${C_RESET} ${C_BOLD}SUMMARY${C_RESET}"
	line="${line} ${C_GREEN}ok=${ok}${C_RESET}"
	line="${line} ${C_YELLOW}skip=${skip}${C_RESET}"
	line="${line} ${C_RED}fail=${fail}${C_RESET}"
	line="${line} ${C_DIM}total=${total}s${C_RESET}"
	if [ -n "$failures_csv" ]; then
		line="${line} ${C_RED}failures=${failures_csv}${C_RESET}"
	fi
	printf '%s' "$line"
}

cmd_exists() {
	command -v "$1" >/dev/null 2>&1
}

is_macos() {
	[ "$(uname -s)" = "Darwin" ]
}

is_linux() {
	[ "$(uname -s)" = "Linux" ]
}

is_wsl() {
	# WSL1/WSL2 detection heuristics.
	# Prefer env var; fall back to /proc markers.
	if [ -n "${WSL_DISTRO_NAME:-}" ]; then
		return 0
	fi
	if [ -f /proc/sys/kernel/osrelease ] && grep -qi microsoft /proc/sys/kernel/osrelease; then
		return 0
	fi
	if [ -f /proc/version ] && grep -qi microsoft /proc/version; then
		return 0
	fi
	return 1
}

module_supported() {
	# When UPDATES_ALLOW_NON_DARWIN=1 is set, allow command-driven modules to run
	# on unknown platforms, but still treat OS-specific modules as unsupported.
	case "$1" in
	brew | node | python | pipx | rustup | claude) return 0 ;;
	linux) is_linux ;;
	mas | macos) is_macos ;;
	*) return 1 ;;
	esac
}

require_supported_platform() {
	if is_macos || is_linux; then
		return 0
	fi
	if [ "${UPDATES_ALLOW_NON_DARWIN:-0}" = "1" ]; then
		warn "Unsupported OS detected; continuing because UPDATES_ALLOW_NON_DARWIN=1 is set."
		return 0
	fi
	die "This script targets macOS and Linux. Set UPDATES_ALLOW_NON_DARWIN=1 to bypass."
}

validate_only_modules_supported() {
	if [ "${#only_modules[@]}" -eq 0 ]; then
		return 0
	fi

	local m
	for m in "${only_modules[@]}"; do
		if module_supported "$m"; then
			continue
		fi
		die "$m: module is not supported on this platform"
	done
}

run() {
	debug "+ $*"
	if [ "$DRY_RUN" -eq 1 ]; then
		return 0
	fi
	"$@"
}

contains_word() {
	local needle="$1"
	shift
	local item
	for item in "$@"; do
		if [ "$item" = "$needle" ]; then
			return 0
		fi
	done
	return 1
}

normalize_module_list() {
	# Converts a CSV list like "brew, mas,python" to space-separated words.
	local s="$1"
	s="${s//,/ }"
	print "$s"
}

is_module_known() {
	case "$1" in
	brew | linux | node | python | mas | pipx | rustup | claude | macos) return 0 ;;
	*) return 1 ;;
	esac
}

module_description() {
	case "$1" in
	brew) print "Update Homebrew formulae/casks" ;;
	linux) print "Upgrade Linux system packages" ;;
	node) print "Upgrade global npm packages via ncu" ;;
	python) print "Upgrade global Python packages via pip" ;;
	mas) print "Upgrade Mac App Store apps via mas" ;;
	pipx) print "Upgrade pipx-managed apps via pipx" ;;
	rustup) print "Update Rust toolchains via rustup" ;;
	claude) print "Update Claude Code CLI" ;;
	macos) print "List available macOS software updates" ;;
	*) print "" ;;
	esac
}

list_modules() {
	local m
	for m in brew linux node python mas pipx rustup claude macos; do
		printf '%-8s %s\n' "$m" "$(module_description "$m")"
	done
}

usage() {
	cat <<EOF
${SCRIPT_NAME} v${UPDATES_VERSION}

Updates common tooling on macOS and Linux (Homebrew, npm globals, pip globals, etc.).

Usage:
  ${SCRIPT_NAME} [options]

Options:
  -h, --help               Show this help
      --version            Print version
      --list-modules       List available modules
      --dry-run            Print what would run; make no changes
      --only <list>        Run only these modules (CSV; or quote a space-separated list)
      --skip <list>        Skip these modules (CSV; or quote a space-separated list)
      --strict             Stop on first failure
  -q, --quiet              Reduce output
  -v, --verbose            Print commands as they run
      --no-emoji           Disable emoji in output
      --no-color           Disable ANSI colors in output
      --log-file <path>    Tee output to a log file
      --non-interactive    Avoid interactive prompts when possible
      --parallel <N>       Parallelism for pip upgrades (default: ${PARALLEL})
      --python-break-system-packages
                            Pass --break-system-packages to pip (dangerous)
      --[no-]brew-greedy   Include greedy cask upgrades (default: enabled)
      --[no-]brew-cleanup  Run brew cleanup after upgrade (default: enabled)

Examples:
  ${SCRIPT_NAME}
  ${SCRIPT_NAME} --dry-run
  ${SCRIPT_NAME} --only brew,node
  ${SCRIPT_NAME} --skip python --log-file ./updates.log

EOF
}

parse_args() {
	while [ $# -gt 0 ]; do
		case "$1" in
		-h | --help)
			usage
			exit 0
			;;
		--version)
			print "${UPDATES_VERSION}"
			exit 0
			;;
		--list-modules)
			list_modules
			exit 0
			;;
		--dry-run)
			DRY_RUN=1
			;;
		--strict)
			STRICT=1
			;;
		-q | --quiet)
			QUIET=1
			;;
		-v | --verbose)
			VERBOSE=1
			;;
		--no-emoji)
			NO_EMOJI=1
			;;
		--no-color)
			NO_COLOR_OUTPUT=1
			;;
		--non-interactive)
			NON_INTERACTIVE=1
			;;
		--python-break-system-packages)
			PYTHON_BREAK_SYSTEM_PACKAGES=1
			;;
		--log-file)
			shift
			[ $# -gt 0 ] || die "--log-file requires a path"
			LOG_FILE="$1"
			;;
		--parallel)
			shift
			[ $# -gt 0 ] || die "--parallel requires a number"
			PARALLEL="$1"
			case "$PARALLEL" in
			'' | *[!0-9]*)
				die "--parallel must be a positive integer"
				;;
			esac
			if [ "$PARALLEL" -lt 1 ]; then
				die "--parallel must be >= 1"
			fi
			;;
		--only)
			shift
			[ $# -gt 0 ] || die "--only requires a module list"
			local list
			list="$(normalize_module_list "$1")"
			local m
			for m in $list; do
				is_module_known "$m" || die "Unknown module in --only: $m"
				only_modules+=("$m")
			done
			;;
		--skip)
			shift
			[ $# -gt 0 ] || die "--skip requires a module list"
			local list
			list="$(normalize_module_list "$1")"
			local m
			for m in $list; do
				is_module_known "$m" || die "Unknown module in --skip: $m"
				skip_modules+=("$m")
			done
			;;
		--brew-greedy)
			BREW_GREEDY=1
			;;
		--no-brew-greedy)
			BREW_GREEDY=0
			;;
		--brew-cleanup)
			BREW_CLEANUP=1
			;;
		--no-brew-cleanup)
			BREW_CLEANUP=0
			;;
		--)
			shift
			break
			;;
		-*)
			die "Unknown option: $1"
			;;
		*)
			die "Unexpected argument: $1"
			;;
		esac
		shift
	done
}

module_selected() {
	local name="$1"

	if contains_word "$name" "${skip_modules[@]}"; then
		return 1
	fi

	if [ "${#only_modules[@]}" -gt 0 ]; then
		contains_word "$name" "${only_modules[@]}"
		return $?
	fi

	module_supported "$name"
}

module_dependency_missing() {
	# In --only mode, missing deps should be treated as an error.
	if [ "${#only_modules[@]}" -gt 0 ]; then
		return 0
	fi
	return 1
}

ensure_cmd_or_skip() {
	local cmd="$1"
	local module="$2"
	if cmd_exists "$cmd"; then
		return 0
	fi

	if module_dependency_missing; then
		err "$module: required command not found: $cmd"
		return 1
	fi

	log "Skipping $module: $cmd not found."
	return 2
}

json_pairs() {
	# Prints tab-delimited key/value pairs from a JSON object on stdin.
	if cmd_exists python3; then
		python3 -c 'import sys, json; obj=json.load(sys.stdin); [print(f"{k}\t{v}") for k,v in obj.items()]'
		return $?
	fi
	if cmd_exists node; then
		node -e 'let d="";process.stdin.on("data",c=>d+=c);process.stdin.on("end",()=>{const o=JSON.parse(d||"{}");for(const k of Object.keys(o)){process.stdout.write(k+"\t"+o[k]+"\n");}});'
		return $?
	fi
	return 1
}

python_externally_managed() {
	if ! cmd_exists python3; then
		return 1
	fi

	local out
	if ! out="$(
		python3 -c 'import sysconfig, pathlib; paths=sysconfig.get_paths(); c=[pathlib.Path(paths[k])/"EXTERNALLY-MANAGED" for k in ("stdlib","platstdlib","purelib","platlib") if paths.get(k)]; print("1" if any(p.exists() for p in c) else "0")' 2>/dev/null
	)"; then
		return 1
	fi
	[ "$out" = "1" ]
}

module_brew() {
	log "Homebrew $(emoji "üç∫")"
	ensure_cmd_or_skip brew brew || return $?

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: brew update"
		if [ "$BREW_GREEDY" -eq 1 ]; then
			log "DRY RUN: brew upgrade --greedy"
		else
			log "DRY RUN: brew upgrade"
		fi
		if [ "$BREW_CLEANUP" -eq 1 ]; then
			log "DRY RUN: brew cleanup"
		fi
		return 0
	fi

	run brew update || return 1

	if [ "$BREW_GREEDY" -eq 1 ]; then
		run brew upgrade --greedy || return 1
	else
		run brew upgrade || return 1
	fi

	if [ "$BREW_CLEANUP" -eq 1 ]; then
		run brew cleanup || return 1
	fi

	return 0
}

module_linux() {
	if ! is_linux; then
		return 2
	fi

	log "Linux system packages $(emoji "üêß")"

	local pm=""
	if cmd_exists apt-get; then
		pm="apt-get"
	elif cmd_exists dnf; then
		pm="dnf"
	elif cmd_exists yum; then
		pm="yum"
	elif cmd_exists pacman; then
		pm="pacman"
	elif cmd_exists zypper; then
		pm="zypper"
	elif cmd_exists apk; then
		pm="apk"
	else
		if module_dependency_missing; then
			err "linux: no supported package manager found (apt-get/dnf/yum/pacman/zypper/apk)"
			return 1
		fi
		log "Skipping linux: no supported package manager found."
		return 2
	fi

	local -a sudo_prefix=()
	if [ "$(id -u)" -ne 0 ]; then
		if ! cmd_exists sudo; then
			err "linux: requires root or sudo"
			return 1
		fi
		sudo_prefix=(sudo)
		if [ "$NON_INTERACTIVE" -eq 1 ]; then
			sudo_prefix=(sudo -n)
		fi
	fi

	case "$pm" in
	apt-get)
		local -a env_prefix=()
		if [ "$NON_INTERACTIVE" -eq 1 ]; then
			env_prefix=(env DEBIAN_FRONTEND=noninteractive)
		fi

		local -a update_cmd=("${sudo_prefix[@]}" "${env_prefix[@]}" apt-get update)
		local -a upgrade_cmd=("${sudo_prefix[@]}" "${env_prefix[@]}" apt-get upgrade)
		if [ "$NON_INTERACTIVE" -eq 1 ]; then
			upgrade_cmd+=(-y)
		fi

		if [ "$DRY_RUN" -eq 1 ]; then
			log "DRY RUN: ${update_cmd[*]}"
			log "DRY RUN: ${upgrade_cmd[*]}"
			return 0
		fi

		run "${update_cmd[@]}" || return 1
		run "${upgrade_cmd[@]}" || return 1
		return 0
		;;
	dnf)
		local -a upgrade_cmd=("${sudo_prefix[@]}" dnf upgrade)
		if [ "$NON_INTERACTIVE" -eq 1 ]; then
			upgrade_cmd+=(-y)
		fi

		if [ "$DRY_RUN" -eq 1 ]; then
			log "DRY RUN: ${upgrade_cmd[*]}"
			return 0
		fi

		run "${upgrade_cmd[@]}" || return 1
		return 0
		;;
	yum)
		local -a upgrade_cmd=("${sudo_prefix[@]}" yum update)
		if [ "$NON_INTERACTIVE" -eq 1 ]; then
			upgrade_cmd+=(-y)
		fi

		if [ "$DRY_RUN" -eq 1 ]; then
			log "DRY RUN: ${upgrade_cmd[*]}"
			return 0
		fi

		run "${upgrade_cmd[@]}" || return 1
		return 0
		;;
	pacman)
		local -a upgrade_cmd=("${sudo_prefix[@]}" pacman -Syu)
		if [ "$NON_INTERACTIVE" -eq 1 ]; then
			upgrade_cmd+=(--noconfirm)
		fi

		if [ "$DRY_RUN" -eq 1 ]; then
			log "DRY RUN: ${upgrade_cmd[*]}"
			return 0
		fi

		run "${upgrade_cmd[@]}" || return 1
		return 0
		;;
	zypper)
		local -a refresh_cmd=("${sudo_prefix[@]}" zypper refresh)
		local -a update_cmd=("${sudo_prefix[@]}" zypper update)
		if [ "$NON_INTERACTIVE" -eq 1 ]; then
			refresh_cmd+=(--non-interactive)
			update_cmd+=(--non-interactive)
		fi

		if [ "$DRY_RUN" -eq 1 ]; then
			log "DRY RUN: ${refresh_cmd[*]}"
			log "DRY RUN: ${update_cmd[*]}"
			return 0
		fi

		run "${refresh_cmd[@]}" || return 1
		run "${update_cmd[@]}" || return 1
		return 0
		;;
	apk)
		local -a update_cmd=("${sudo_prefix[@]}" apk update)
		local -a upgrade_cmd=("${sudo_prefix[@]}" apk upgrade)

		if [ "$DRY_RUN" -eq 1 ]; then
			log "DRY RUN: ${update_cmd[*]}"
			log "DRY RUN: ${upgrade_cmd[*]}"
			return 0
		fi

		run "${update_cmd[@]}" || return 1
		run "${upgrade_cmd[@]}" || return 1
		return 0
		;;
	*)
		err "linux: unsupported package manager: $pm"
		return 1
		;;
	esac
}

module_node() {
	log "npm globals $(emoji "üì¶")"
	ensure_cmd_or_skip ncu node || return $?
	ensure_cmd_or_skip npm node || return $?

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: ncu -g --jsonUpgraded"
		log "DRY RUN: npm install -g -- <packages...>"
		return 0
	fi

	local json
	if ! json="$(ncu -g --jsonUpgraded)"; then
		err "node: ncu failed"
		return 1
	fi

	local pairs
	if ! pairs="$(printf '%s' "$json" | json_pairs)"; then
		err "node: failed to parse ncu JSON output"
		return 1
	fi

	local -a packages=()
	local name ver
	while IFS=$'\t' read -r name ver; do
		[ -n "$name" ] || continue
		packages+=("${name}@${ver}")
	done <<<"$pairs"

	if [ "${#packages[@]}" -eq 0 ]; then
		log "All global npm packages are up-to-date. $(emoji "‚úÖ")"
		return 0
	fi

	log "Upgrading global npm packages:"
	local p
	for p in "${packages[@]}"; do
		log "  - $p"
	done

	run npm install -g -- "${packages[@]}" || return 1
	return 0
}

module_python() {
	log "Python globals $(emoji "üêç")"
	ensure_cmd_or_skip python3 python || return $?

	if ! python3 -m pip --version >/dev/null 2>&1; then
		if module_dependency_missing; then
			err "python: required module not found: pip (python3 -m pip)"
			return 1
		fi
		log "Skipping python: pip not available (python3 -m pip)."
		return 2
	fi

	local use_user=0
	local break_system=0
	if [ "$PYTHON_BREAK_SYSTEM_PACKAGES" -eq 1 ]; then
		break_system=1
	elif python_externally_managed; then
		use_user=1
		log "python: externally-managed environment detected; upgrading user-site packages."
		log "python: use --python-break-system-packages to override (dangerous)."
	fi

	local -a pip_list_args=(python3 -m pip --disable-pip-version-check list --outdated --format=json)
	local -a pip_install_args=(python3 -m pip --disable-pip-version-check install -U)
	if [ "$NON_INTERACTIVE" -eq 1 ]; then
		pip_install_args+=(--no-input)
	fi
	if [ "$use_user" -eq 1 ]; then
		pip_list_args+=(--user)
		pip_install_args+=(--user)
	fi
	if [ "$break_system" -eq 1 ]; then
		pip_install_args+=(--break-system-packages)
	fi

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: ${pip_list_args[*]}"
		log "DRY RUN: ${pip_install_args[*]} <package>  (parallel: ${PARALLEL})"
		return 0
	fi

	local outdated_json
	if ! outdated_json="$("${pip_list_args[@]}")"; then
		err "python: failed to query outdated packages"
		return 1
	fi

	local names
	if ! names="$(printf '%s' "$outdated_json" | python3 -c 'import sys, json; data=json.load(sys.stdin); print("\n".join([p.get("name","") for p in data if p.get("name")]))' 2>/dev/null)"; then
		err "python: failed to parse pip output"
		return 1
	fi

	local -a packages=()
	local pkg
	while IFS= read -r pkg; do
		[ -n "$pkg" ] || continue
		packages+=("$pkg")
	done <<<"$names"

	if [ "${#packages[@]}" -eq 0 ]; then
		if [ "$use_user" -eq 1 ]; then
			log "All user-site Python packages are up-to-date. $(emoji "‚úÖ")"
		else
			log "All Python packages are up-to-date. $(emoji "‚úÖ")"
		fi
		return 0
	fi

	if [ "$PARALLEL" -lt 1 ] 2>/dev/null; then
		PARALLEL=1
	fi

	log "Upgrading ${#packages[@]} Python packages (parallel: ${PARALLEL})..."

	local -a pids=()
	local -a pid_pkgs=()
	local failed=0

	for pkg in "${packages[@]}"; do
		debug "+ ${pip_install_args[*]} $pkg"
		"${pip_install_args[@]}" "$pkg" &
		pids+=("$!")
		pid_pkgs+=("$pkg")

		if [ "${#pids[@]}" -ge "$PARALLEL" ]; then
			local pid="${pids[0]}"
			local pid_pkg="${pid_pkgs[0]}"
			if ! wait "$pid"; then
				err "python: pip upgrade failed: $pid_pkg"
				failed=1
			fi
			pids=("${pids[@]:1}")
			pid_pkgs=("${pid_pkgs[@]:1}")
		fi
	done

	local i
	for i in "${!pids[@]}"; do
		if ! wait "${pids[$i]}"; then
			err "python: pip upgrade failed: ${pid_pkgs[$i]}"
			failed=1
		fi
	done

	if [ "$failed" -ne 0 ]; then
		return 1
	fi
	return 0
}

module_mas() {
	log "Mac App Store $(emoji "üõçÔ∏è")"
	ensure_cmd_or_skip mas mas || return $?

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: mas upgrade"
		return 0
	fi

	run mas upgrade || return 1
	return 0
}

module_pipx() {
	log "pipx $(emoji "üß∞")"
	ensure_cmd_or_skip pipx pipx || return $?

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: pipx upgrade-all"
		return 0
	fi

	run pipx upgrade-all || return 1
	return 0
}

module_rustup() {
	log "Rust $(emoji "ü¶Ä")"
	ensure_cmd_or_skip rustup rustup || return $?

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: rustup update"
		return 0
	fi

	run rustup update || return 1
	return 0
}

module_claude() {
	log "Claude Code $(emoji "ü§ñ")"
	ensure_cmd_or_skip claude claude || return $?

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: claude update"
		return 0
	fi

	run claude update || return 1
	return 0
}

module_macos() {
	log "macOS updates $(emoji "üçè")"
	ensure_cmd_or_skip softwareupdate macos || return $?

	if [ "$DRY_RUN" -eq 1 ]; then
		log "DRY RUN: softwareupdate -l"
		return 0
	fi

	run softwareupdate -l || return 1
	return 0
}

csv_join() {
	local IFS=,
	print "$*"
}

run_selected_modules() {
	successes=()
	skipped=()
	failures=()

	local m
	for m in brew linux node python mas pipx rustup claude macos; do
		if ! module_selected "$m"; then
			continue
		fi

		log "$(format_boundary_start "$m")"
		local start="$SECONDS"

		debug "Running module: $m"
		local rc=0
		"module_${m}"
		rc=$?
		local dur=$((SECONDS - start))

		if [ "$rc" -eq 0 ]; then
			successes+=("$m")
			log "$(format_boundary_end "$m" OK "$dur")"
			continue
		fi

		# 2 means "skipped due to missing dependency"
		if [ "$rc" -eq 2 ]; then
			skipped+=("$m")
			log "$(format_boundary_end "$m" SKIP "$dur")"
			continue
		fi

		failures+=("$m")
		log "$(format_boundary_end "$m" FAIL "$dur")"
		if [ "$STRICT" -eq 1 ]; then
			return 1
		fi
	done

	if [ "${#failures[@]}" -gt 0 ]; then
		return 1
	fi
	return 0
}

on_interrupt() {
	local code="$1"
	local sig="$2"
	err "Interrupted ($sig)."
	exit "$code"
}

main() {
	parse_args "$@"

	if [ -n "$LOG_FILE" ]; then
		mkdir -p "$(dirname "$LOG_FILE")" || die "Failed to create log dir"
		exec > >(tee -a "$LOG_FILE") 2>&1
	fi

	init_colors

	require_supported_platform
	validate_only_modules_supported

	trap 'on_interrupt 130 SIGINT' INT
	trap 'on_interrupt 143 SIGTERM' TERM

	log "Starting updates..."
	SECONDS=0

	local rc=0
	if run_selected_modules; then
		local total="${SECONDS}"
		log "$(format_summary "${#successes[@]}" "${#skipped[@]}" "${#failures[@]}" "$total")"
		log "Done in ${total}s. $(emoji "üéâ")"
		return 0
	fi

	local total="${SECONDS}"
	local failures_csv=""
	if [ "${#failures[@]}" -gt 0 ]; then
		failures_csv="$(csv_join "${failures[@]}")"
	fi
	log "$(format_summary "${#successes[@]}" "${#skipped[@]}" "${#failures[@]}" "$total" "$failures_csv")"
	err "Completed in ${total}s with failures: ${failures[*]}"
	return 1
}

main "$@"
